package goattribution // Generated by https://quicktype.io

import (
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"

	"github.com/gif-gif/go.io/go-marketing/goattribution/cryptography"
	goutils "github.com/gif-gif/go.io/go-utils"
	"github.com/gogf/gf/util/gconv"
	"github.com/zeromicro/go-zero/core/logx"
)

type FacebookUtmContent struct {
	App    int64 `json:"app"`
	T      int64 `json:"t"`
	Source struct {
		Data  string `json:"data"`
		Nonce string `json:"nonce"`
	} `json:"source"`
}

type FacebookAd struct {
	AdID              int64       `json:"ad_id"`
	AdObjectiveName   string      `json:"ad_objective_name"`
	AdGroupID         int64       `json:"adgroup_id"`
	AdGroupName       string      `json:"adgroup_name"` //ad名称
	CampaignID        int64       `json:"campaign_id"`
	CampaignName      string      `json:"campaign_name"` //adset名称
	CampaignGroupID   int64       `json:"campaign_group_id"`
	CampaignGroupName string      `json:"campaign_group_name"` //campaign名称
	AccountID         int64       `json:"account_id"`
	IsInstagram       bool        `json:"is_instagram"`
	PublisherPlatform string      `json:"publisher_platform"`
	PlatformPosition  interface{} `json:"platform_position"`
}

type FacebookAttributeHandler struct {
	DecryptKey string
}

func (h *FacebookAttributeHandler) Channel() string {
	return CHANNEL_META
}

func (h *FacebookAttributeHandler) Match(queryParams url.Values) bool {
	return strings.Contains(queryParams.Get("utm_source"), h.Channel()) || strings.Contains(queryParams.Get("utm_source"), "facebook")
}

func (h *FacebookAttributeHandler) Handle(queryParams url.Values) (*AttributeInfo, error) {

	utm_medium := strings.TrimSpace(queryParams.Get("utm_medium"))
	utm_source := strings.TrimSpace(queryParams.Get("utm_source"))

	if strings.Contains("facebook.com", utm_medium) || strings.Contains("meta.com", utm_source) {
		return CreateBaseAttributeInfo(queryParams, h.Channel()), nil
	}

	key := []byte(h.DecryptKey)
	info, err := h.DecryptFacebookAttribute(queryParams, queryParams.Get("utm_content"), key)
	if err != nil {
		//logx.Errorf("FacebookAttributeHandler handle DecryptFacebookAttribute error:%v queryParams:%+v", err, queryParams)
		return nil, err
	}
	return info, nil
}

func (h *FacebookAttributeHandler) DecryptFacebookAttribute(queryParams url.Values, content string, key []byte) (*AttributeInfo, error) {
	facebookAd, err := h.DecryptFacebookAd(content, key)
	if err != nil {
		return nil, err
	}
	info, err := CreateAttributeInfo(queryParams, gconv.String(facebookAd.CampaignID), facebookAd.CampaignName)
	info.Channel = h.Channel()
	return info, err
}

func (h *FacebookAttributeHandler) DecryptFacebookAd(content string, key []byte) (*FacebookAd, error) {
	if len(key) == 0 {
		return nil, errors.New("key cannot be empty")
	}
	var utmContent FacebookUtmContent
	err := json.Unmarshal(goutils.StringToBytes(content), &utmContent)
	if err != nil {
		return nil, err
	}

	data := goutils.StringToBytes(utmContent.Source.Data)
	n, err := hex.Decode(data, data)
	if err != nil {
		return nil, fmt.Errorf("decode data error:%v,data:%s", err, utmContent.Source.Data)
	}
	cipherText := data[:n]

	nonceData := goutils.StringToBytes(utmContent.Source.Nonce)
	n, err = hex.Decode(nonceData, nonceData)
	if err != nil {
		return nil, fmt.Errorf("decode Nonce error:%v,nonce:%s", err, utmContent.Source.Nonce)
	}
	nonce := nonceData[:n]
	data, err = cryptography.AesGcmDecrypt(cipherText, key, nonce)
	if err != nil {
		return nil, fmt.Errorf("AesGcmDecrypt error:%v txt:%s key:%s nonce:%s", err, cipherText, key, nonce)
	}
	logx.Infof("DecryptFacebookAd:%s", data)
	var result FacebookAd
	err = json.Unmarshal(data, &result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}
